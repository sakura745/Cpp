# 对象与基本类型
## 1.初始化、赋值 
c++是强类型语言（所有操作与类型相关），程序中最基本的操作，是将某一个值与一个对象关联起来
`initialization.cpp`

## 2.类型详述
### 类型
类型是一个编译器的概念，可执行程序中不存在这一概念。类型的引入是为了更好的描述程序，防止误用。

类型描述了四种信息：存储尺寸、取值空间、对齐信息和可执行操作。
`type1.cpp` 

类型分为基本（内建）类型和复杂类型。

基本类型
- 字符类型(对应ASCII)、整数类型和浮点类型
- `void`：是为了满足C++强类型这一特性而创造的

复杂类型：是由基本类型组合、变种所产生的类型，可能是标准库的引入`std::string`或自定义类型

### 字面值
程序中直接表示为一个具体数值或字符串的值，每个字面值都有类型
- 整数 `int`
- 浮点数 `double`
- 字符字面值 `char`
- 字符串字面值 `char[4]`
- 布尔字面值 `bool`
- 指针字面值 `nullptr_t`

`type2.cpp`
### 变量
变量初始化有多种，为变量赋值可能涉及到类型转化。
`variable.cpp` `auxilsource.cpp`

类型转换
`typeConversion.cpp`
### 符合类型：指针和引用
#### 指针
指针是对对象的间接使用，指针的**优点**：
- 指针复制成本低：对于自定义的类型而言，只占了8个字节，有很大的优势
- 读写成本高：函数参数通过传地址，高于传值

`pointer.cpp`

#### 引用
指针的问题是可能非空，地址信息可能非法（指针涉及到两块内存，因此是两个问题），从而引入**引用**，引用是对象的别名。
引用的底层还是指针。对于汇编语言来说，没有别名这个概念。

`reference.cpp`
## 3.常量类型与常量表达式
### 常量类型
`const`不是类型，是限定符，属于**编译期**概念，不受硬件支持。

变量底层是可以对内存空间进行读和写操作的，属于底层硬件支持。

本质上，对于内存空间来说，变量和常量没有区别。

作用是防止非法操作和优化程序逻辑，保证变量变成具有**只读**属性的常量。

变量后期使用时不会修改，则尽量将其声明为常量。

`const`可修改左、右值，用于函数形参。
### 常量表达式
常量表达式`constexpr`，也是编译期常量，编译器同样在编译期对其优化。

`constexpr`表示百分百可用于编译阶段。

**常量引用主要用于函数形参**

对于复杂类型，如`int*` `const`和`constexpr`是有区别的
## 4.类型别名和类型自动推导
### 类型别名
可以引入特殊的含义或者便于使用。

`typeAlias.cpp`

### 类型自动推导
`autodeduction.cpp`

当左值转为右值时，会引入类型退化


自动推导可能会产生类型退化decay:都变为`int`:`const int`--> `int`;`int&`-->`int`;`const int&`-->`int`

`auto`会产生退化(但不会退化指针，`const int*`--> `const int*`，因为`const`为底层，如果是`int* const`，依然会退化）

`auto&`会**避免类型退化**，但是会推导出**引用**类型，引入`&`

`decltype(exp/val)`会保持原有类型，避免退化。
如果为exp(左值) （只有表达式才分左、右值），则为`exp类型`+`&`；如果为val(变量)，则为`val类型`；
若既可以视为表达式，又可以视为变量，则当做变量来处理。val变量可以改为表达式：`(val) = exp`(变量加一个括号)


## 5.域与对象的生命周期
`scope.cpp`

域表示程序中的一部分，其中的名称有唯一的含义。

对象的生命周期起始于被初始化的时刻，终止于被销毁的时刻。对象被销毁时，会从缓冲区输出。

在栈上构造，会自动销毁。在堆上构造，需要显式销毁。



