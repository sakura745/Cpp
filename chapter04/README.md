# 对象与基本类型
## 1.表达式基础
### 表达式
`expression.cpp`
表达式是由一到多个操作数组成，操作数和运算符组成。

`x = 3;`有分号为语句

`x = 3`没有分号为表达式

运算符的特性：接受操作数不同，操作数的类型转换，操作数为左、右值，返回结果的类型，优先级与结合性等

优先级与结合性是一一对应的（就是这么设计的）。

### 左值与右值
`lvalRval.cpp`

左右值的划分是针对表达式或表达式求值结果的，而不是针对对象或数值的。

表达式有泛左值`glvalue`和右值`rvalue`，泛左值有左值`rvalue`和将亡值`xvalue`，右值有将亡值`xvalue`和纯右值`prvalue`。(左值和右值分出的将亡值是同一种)。
纯右值和泛左值相对应。
- `glvalue`:标识一个对象、位或函数
- `prvalue`:用于初始化对象或为操作数
- `xvalue`:表示其资源可以被重新使用，要消亡

表达式是左值还是右值，是通过这三个推导出来的。

`lvalue`：“先是`glvalue`，然后不是`xvalue`”，意味着左值是标识一个对象、位或函数且资源属于它本身。含有地址信息的表达式。

`rvalue`:可能是`xvalue`，意味着是用于标识一个对象、位或函数，但要被销毁的值；也可能`prvalue`是纯右值。

**`rvalue reference`是只能绑定到'临时对象的引用'**,可以让临时对象不被消亡

左值可以转化为右值；纯右值可以转化为将亡值(Temporary Materialization)

可以通过`decltype(exp)`来判断左右值：

有`decltype(a) b`:如果`b`的类型和`a`相同，则`a`为纯右值；如果`b`的类型是`a&`，则`a`为左值；
如果`b`的类型为`a&&`，则`a`为将亡值
### 类型转换
`typeConvert.cpp`

隐式类型转换由编译器自动完成，是一个**多步转换**的顺序。

显式类型转换不只有四种。

`static_cast`静态，编译器执行，性能强，但安全性差；不能去除变量的常量性
，但`const_cast`可以去除

`dynamic_cast`运行器执行，更安全，但性能差

`const_cast`改变（去除或增加）变量的常量性

`reinterpret_cast`多用于指针，重新解释当前内存

C形式的类型转换[explicit_cast](https://en.cppreference.com/w/cpp/language/explicit_cast):`(int)3.14`，不建议在`c++`中使用

**不建议使用显式类型转换，尽可能的使用隐式类型转换。**

## 2.表达式详述
### 算数操作符 
`arithmeticOperator.cpp`

**一元**操作符 `+` `-`，配合auto使用，会产生integral promotion
### 逻辑与关系操作符
逻辑与、或具有短路特性。逻辑与的优先级高于逻辑或，但使用时建议加上`()`，提高代码可读性

不要写出`if (val == true)`这种代码，改为`if (val)`
### 位操作符
位操作符在计算过程中，可能会出现integral promotion。是因为对应与硬件来说，最常用的数据类型为int型。

数值在计算机中都是用补码的形式表示的。

### 赋值操作符
赋值操作符是右结合，right to left，求值结果（表达式返回）为左操作数。

可以引入`{}`初始化列表，来防止收缩转换，把warning变为error
### 自增与自减操作符
`++a`等价与`a += 1`

分为后缀和前缀两种。建议使用前缀形式，因为后缀要有个tmp存储原始值，有额外空间。

`x = x + 1`前缀时，返回左值(等号左边的x)；后缀时，返回右值(等号右边的x)。

### 其他操作符
**成员访问**操作符 `.` `->`，访问结构体或者类中的成员函数。

**条件**操作符 `a ? b : c` a为bool类型表达式，b和c为相同类型的表达式，如果b和c均为左值，则该操作符返回左值，否则返回右值。

右结合 right to left 

**逗号**操作符

**sizeof**操作符

等