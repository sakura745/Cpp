## 1.异常处理
C语言处理方法：传返回值表示函数调用是否正常结束

C++处理方法：通过关键字 `try/catch/throw` 引入异常处理机制
- `throw`产生异常
- `try`判断是否有异常
- `catch`捕获异常

`exception.cc`

异常触发时，系统的行为：**栈展开**
 
异常对象：抛出的异常拷贝初始化一个临时对象(`throw 异常对象`)

`try/catch`语句块
- `try`和`catch`一定是成对出现的
- `throw`出异常， `catch`捕获，只有三种情况会存在类型转化:xxx->const xxx, xxx[] -> xxx*, Derive -> Base
- `catch(...)` 匹配任意异常
- `catch`语句中使用`throw`，抛出`catch`接受到的异常

在一个异常处理未完成（没被`catch`捕获）时，抛出新的异常会导致系统崩溃
- 不要在析构函数或`operator delete`函数重载版本中抛出异常
- 通常来讲， `catch`接收异常类型为引用类型

`exception2.cc`

`function-try-block`
- 对类的构造函数的初始化列表进行`try`，在构造函数体外使用`catch`
- 一般函数也可以使用，不捕捉从按值传递的函数形参的复制/移动构造函数和析构函数中抛出的异常

既然一般函数的try-block不捕捉，那其意义是什么
- 可读性好，不用再缩进，try和函数体共享`{}`
- 抛出异常被捕获的位置也不同，使用try-block是被其catch捕获，不使用，被其他外部catch捕获

`exception3.cc`

描述函数是否会抛出异常
- 如果函数不抛出异常，则会为系统提供更多的优化空
  1) C++98: `throw()`/ `throw(int, char)`
  2) C++11及其之后: `noexcept` / `noexcept(false)`

c++98会抛出int等类型信息，是在编译期运行的；但c++11之后，使用noexcept(false)没有给信息在编译期，会在运行期处理异常是一个
改进

`noexcept`
- 限定符：`void fun() noexcept {}`
- 操作符：接收一个表达式，根据表达式是否 **可能** 会抛出异常返回`false`或者`true`
- 如果在`noexcept`中抛出异常，则会导致`terminate`被调用。即使哦那个`try-catch`也不会被捕捉到异常
- 不作为重载依据，使用函数指针和虚函数重写要保持形式兼容

`exception4.cc`
![微信图片_20240629185105](https://github.com/sakura745/Picx_image_host/raw/master/20240629/微信图片_20240629185105.33drlhch4ni0.webp)

C++标准异常:希望抛出标准异常，信息越多，可读性越好
 
正确对待异常处理
- 不要滥用：异常执行成本比较高
- 不要不用：真正异常的场景，异常处理较高效、简洁的处理方式
- 编写异常安全的代码

## 2.枚举与联合
`enum.cc`

取值受限的特殊类型

无作用域枚举，继承自C语言。但会造成名称污染，两个不同无作用域枚举中，有相同名称，会冲突。因此提出了有作用域枚举

`union.cc`

将多个类型合并到一起以 **节省空间**

联合通常和枚举一起使用
## 3.嵌套类与局部类
`nestClass.cc`

嵌套类是类中还有类，局部类是函数中含有类

可以避免名称污染

嵌套类与外围类有单独的数据成员

嵌套类想要访问外围类的静态数据成员，可以通过嵌套类内构造成员函数中访问，不能直接在嵌套类中访问

局部类不能定义静态数据成员

## 4.嵌套名字空间与匿名名称空间
`nestNamespace.cc`

嵌套名字空间和匿名名字空间
## 5.位域与`volatile`关键字
`bitFields.cc`
 
显示表明对象尺寸（所占位数）

`volatile`:与`const`对应，都是限制符

表明一个对象可能会被当前程序以外的逻辑修改

对于变量的构造来说，先进入缓存，再进入内存中进行读写。但使用`volatile`后表示直接从内存中读写，不经过缓存

对其对象的读写可能会加重程序负担，谨慎使用

之前可能在多线程中使用`volatile`维护数据的同步，但是这是错误的做法。正确的做法是使用`atmoic`来代替