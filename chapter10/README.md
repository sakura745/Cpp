## 1.泛型算法
算法不是方法
 
内建数据类型不支持方法，通过算法的建立，可以避免重复定义

算法多数支持为模板

通过**迭代器**使用，对数据进行相应的算法操作。

当某种功能算法可以实现，方法也可以实现，推荐使用方法。因为对于算法来说，需要支持多种类型，自然而然的比方法会有性能损失。
如`std::find`和`std::map::find`

对于`vector`来说没有`.find()`**方法**，看是否有`std::find()`**算法**以供`vector`使用。

迭代器的类型是严格区分的。输入、输出、前向、双向和随机访问迭代器。

这五类迭代器，难易程度有简单到复杂。如：支持随机访问迭代器的算法，一定支持输入迭代器算法。但是反过来不一定。

特殊迭代器：插入、流、反向和移动迭代器

并发算法

---
《Essential C++》: 

算法通常有重载的两个版本：其一是使用底层元素所属之类型的内置运算符，其二是接收function object或function pointer的传入，
借此提供和内置运算符不同的行为。如`sort(vector.begin(), vector.end())`和`sort(vector.begin(), vector.end()， greater<int>())`

另有一些算法干脆以不同的名称区分不同版本，形成两个函数；以_if为名称后缀的，指“可指定特定行为”。如`find()`和`find_if()`

对于“会更改目标容器的内容”的算法，也都提供两种版本：一种是称为in-place版本，会改变容器的内容；另一种称为copy版本，不改变传入
容器内容，而是先为它制作一份副本，再改变副本的内容，然后返回该副本。如`replace()`和`replace_copy()`。copy版本的名称必包含`_copy`
后缀，此版本的第三个iterator参数，用以指向它所更改的容器的第一个元素。

---

## 2.`bind`与`lambda`表达式

### `bind`
可读性较差

### `lambda`表达式

`lambda`表达式会被编译器翻译成类进行处理

`[捕获](形参)->返回类型 {函数体};`

## 3.`ranges`
对泛型算法的改进。使用容器而非迭代器输入