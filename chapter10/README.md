## 1.泛型算法
`generic.cc`
### 算法和方法的异同
算法是`std::xxx()`，`*.xxx()`是方法
 
内建数据类型不支持方法，通过算法的建立，可以避免重复定义

算法多数支持为模板

当某种功能算法可以实现，方法也可以实现，推荐使用方法。因为对于算法来说，需要支持多种类型，自然而然的比方法会有性能损失。
如`std::find`和`std::map::find`

对于`vector`来说没有`.find()`**方法**，看是否有`std::find()`**算法**以供`vector`使用。

### 迭代器
通过**迭代器**使用，对数据进行相应的算法操作。

迭代器的类型是严格区分的。

这五类迭代器，有输入、输出、前向、双向和随机访问迭代器，难易程度从简单到复杂。如：支持随机访问迭代器的算法，一定支持输入迭代器算法。但是反过来不一定。

特殊迭代器：插入(`back_inserter` `front_inserter` `inserter`)、流(`istream_iterator` `ostream_iterator`)、反向和
移动迭代器(`move_iterator`)

哨兵常用于标识数据结构或算法的结束或边界条件。哨兵的目的是在不需要明确指定数据结构或算法的大小或结束位置的情况下，提
供一个可识别的标志。哨兵只需要与其他迭代器支持判等即可

### 并发算法
并发算法：`std::execution::seq`顺序执行 `std::execution::par`并发执行，多线程 `std::execution::par_unseq` 并发非顺序执行，这三个
是c17，`std::execution::unseq`非顺序，单线程 c20

---
《Essential C++》: 

算法通常有重载的两个版本：其一是使用底层元素所属之类型的内置运算符，其二是接收function object或function pointer的传入，
借此提供和内置运算符不同的行为。如`sort(vector.begin(), vector.end())`和`sort(vector.begin(), vector.end()， greater<int>())`

另有一些算法干脆以不同的名称区分不同版本，形成两个函数；以_if为名称后缀的，指“可指定特定行为”。如`find()`和`find_if()`

对于“会更改目标容器的内容”的算法，也都提供两种版本：一种是称为in-place版本，会改变容器的内容；另一种称为copy版本，不改变传入
容器内容，而是先为它制作一份副本，再改变副本的内容，然后返回该副本。如`replace()`和`replace_copy()`。copy版本的名称必包含`_copy`
后缀，此版本的第三个iterator参数，用以指向它所更改的容器的第一个元素。

---

## 2.`bind`与`lambda`表达式
定义**可调用对象**
- 函数指针：概念直观，但位置受限
- 类：功能强大，但书写麻烦
- `bind`：基于已有的逻辑适配，但可读性一般，尤其是在复杂逻辑的语法
- `lambda`表达式：小巧灵活，功能强大
### `bind`
`bind.cc`通过绑定的方式修改可调用对象的调用方式

`std::placeholders` 用在函数模板中指定占位符参数，`_1`, `_2`, `_3`, ... , `_N` 等占位符，其中 N 是一个正整数。
这些占位符表示在使用时可以被替换成实际参数。一般情况下，`_1` 代表第一个参数，`_2` 代表第二个参数

但使用`bind`传入的参数会被复制，可以使用`std::ref` `std::cref`来避免复制行为
### `lambda`表达式
`lambda`表达式会被编译器翻译成**类**进行处理

相当于函数名称为`[]`的函数，属于轻量级的匿名函数，`[]`的作用是捕获lambda表达式外部的变量以供表达式使用，而不是像常规函数一样直接使用函数
外部的变量，没有像常规函数一样的作用域

`lambda.cc`

`[捕获](形参)->返回类型 {函数体};`

`mutable`与`const`相对应，多应用于**值捕获**，被捕获对象是否改变。没有特定标出为`mutable`
，则表示缺省状态下为`const`，不能修改捕获的值。

`mutable`存在的意义是当对变量使用值捕获时，该变量是只读的，想要在表达式内修改变量，使用`mutable`，使只读的变量变成对
该变量的**副本**的引用

对类的成员函数进行捕获时，用到`this`

- c11 值捕获、引用捕获、混合捕获和`this`捕获
- c14 初始化捕获:无需写初始化类型，auto都不用写，编译器可以自行推断
- c17 `*this`捕获（对`this`解引用，变成值捕获）

`lambda2.cc`

- IIFE(Immediately-Invoked Function Expression)
`[](){} ()/*调用函数表达式*/` 对于构造好的`auto lambda = [](){}`函数来说，`lambda`是没调用，`lambda()`是已调用

## 3.`ranges`
`ranges.cc` c20

对泛型算法的改进。使用**容器**而非**迭代器**作为输入