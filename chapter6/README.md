## 1.函数基础
### 定义与声明
定义的本质是对应一段汇编代码。声明的本质是使用函数告诉编译器有该函数的存在。

函数的定义通常只能出现一次（内联函数除外），而声明可以出现多次。

**当函数没有定义只有声明时，系统会报链接错误而非编译错误**

### 函数调用
函数的调用这一过程中，实现了两次拷贝初始化。其一实参到形参，其二返回值会被拷贝给函数的调用者（如会由函数return的值拷贝给main函数）

结构为栈帧结构（stack frame）：内存地址从高到低的顺序



## 2.函数参数
函数的形参可以包含零到多个。

形参名称的变化并不会引入函数不同的版本



### 函数传值、传址和传引用

### 传参过程中类型退化
拷贝初始化会导致类型退化

避免类型退化，可以使用引用`&`

### 可变长参数
函数输入参数为：初始化列表为参数`{1, 2, 3}`也行，`{1, 2, 3， 4}`也行。`{}`可以初始化初始化列表，也可以初始vector

函数返回参数为初始化列表，类型`initializer_list<int>`，但是会有风险。

### 缺省实参
没有缺省形参说法。函数定义时，形参初始化，就称之为缺省实参。

函数有多个形参时，其中一个形参为缺省实参，则该形参右侧的形参都必须具有缺省实参

**设计函数的形参列表中，形参顺序的优先级由高到低为从左到右，不重要的形参都有缺省值，重要的没有缺省值**

### `main`函数的两个版本
`int main(int argc, char* argv[])`

`argument count, argument value` `argv`是指针的数组，每个数组元素是`char*`类型的指针。`argv`数组最后一个元素指向空指针`NULL`

## 3.函数体和返回类型

return返回初始化列表，会有潜在风险。 return引用/指针类型也会有风险。

返回值RVO优化:提高性能---对临时对象有强制优化(c17)

返回类型有三种书写方式:位于函数头的前部，位于函数头的后部(c11)，返回类型的自动推导(c14)

对于c14类型的自动推导，可以通过`constexpr if`来构造具有不同返回类型的函数

返回类型与结构化绑定(c17)--程序更简洁，无新功能

[[nodiscard]]属性(c17)

## 4.函数重载与重载解析
### 函数重载

相同函数名、不同参数列表（类型、数目可以，但名称无关）

不能基于不同的返回类型进行重载

### 重载解析

重载解析：编译器如何选择正确的版本完成函数的调用


## 5.其他函数
### 递归函数

### 内联函数
内联函数不是函数的类型，是一种优化机制

`inline`原本的操作是将函数体`a`直接赋到调用`a`函数的`b`函数中。省去函数调用这一过程。
内联函数的展开不是简单的替换，编译器有自己的操作方式，避免重定义等问题的出现。

`inline`说明符，说明当出现多次函数定义时，不会有重定义的问题出现，链接器会选择一个作为链接。

**把函数的“一次定义”原则，从程序级别变为翻译单元级别。**

### `constexpr`函数
可以在编译器或者运行期调用(c11)

### `consteval`函数
只能在编译器求值(c20)

该函数的目的就是只让在编译器执行，`constexpr`都有可能，才会再设计`consteval`

### 函数指针
从C语言继承过来的概念

函数类型，如`int(int)`对应返回值类型(参数类型)，可以类比于数组类型，都是复合类型。

函数类型是存在的，但是用途比较狭窄，函数指针代替品也比较多。

函数指针用于高阶函数，泛型算法属于高阶函数.

[Most vexing parse](https://en.wikipedia.org/wiki/Most_vexing_parse)促使了C++中特性的提出用`{}`替换`()`，是要构造对象，
而不是声明函数
 